For score_letter, I first checked if num_words == 0 || vocabulary == NULL and if so, then i returned 0. Then I essentially looped through vocabulary and created a function inword that would check if a letter was in a word. If so, then it would return true. By creating if(inword(letter, vocabulary[i])) as a condition, I pretty much incremented a variable  w by 1 that i initialized to 0. This would mean that I would avoid duplicate letters and would be able to check if a letter was in a word. Finally after looping through vocabulary, I returned w. For score_word, I first checked if the word was NULL. If not, then I used the ascii system (a = 97; z = 122) and looped through the alphabet. I set int score = letter_scores[i-97]. This allowed me to get the specific score for the specific letter. I would then loop the alphabet through the word and check if the alphabet would be in the word. If so, then I would first sum += score and then set score = 0 to avoid duplicates. While ineffecient, it seems to work. Finally, the filter_vocab gray, green, and yellow all had similar structure. For gray, I would set size_t w = 0 and then loop through vocabulary where I would check if a word contained a letter. If so, it the word would be freed with free(vocabulary[i]) and vocabulary[i] would be set NULL. Additionally I would increment w by 1. Finally I would return w. Additionally before checking if a word contained a letter, I would also check if the word was not NULL. For green and yellow, it has the same structure but with different conditional statements. For green, I use (!inword(letter, vocabulary[i]) && vocabulary[i][position] != letter). I essentially set the requirments for green and use a ! conditional to create the opposite effect. For yellow, I use (inword(letter, vocabulary[i]) && vocabulary[i][position] == letter). 